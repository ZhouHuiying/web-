### 浏览器缓存

https://www.cnblogs.com/suihang/p/12855345.html  ！！！！

缓存的原理是首次请求后存储一份请求资源的响应副本，当用户再次发起相同请求后，如果缓存命中，则直接将之前存储的副本返回给浏览器，从而避免重新向服务器发起资源请求。
  HTTP缓存是我们日常开发中最常用的一种缓存技术。根据判断缓存命中时，浏览器是否需要向服务器发起请求以询问缓存的相关信息来划分，HTTP缓存又可以分为强缓存和协商缓存。

 - 强缓存：缓存策略都是通过设置HTTP Header来实现的，与强缓存相关的Header字段是 Expires 和 cache-control。
    Expires： Expires是 HTTP1.0 协议中控制缓存失效日期时间戳的字段，是绝对时间，当客户端本地时间超过 Expires 的时间，表示缓存过期。
              Expires: Mon, 21 Apr 2031 01:13:16 GMT

    cache-control：Cache-Control是HTTP1.1协议中控制缓存的字段，Cache-Control 的 max-age 属性控制资源缓存的有效期，是一个以秒为单位的时间长度。
              如下，表示该缓存在资源被请求到后的315360000秒内有效。Cache-Control: max-age=315360000;

              Cache-Control 还可以配置一些其他属性值来控制缓存：
                no-store：禁止使用任何缓存策略，每次请求都去服务器去获取最新资源。
                no-cache：每次发起请求不会直接进入强缓存的过期校验，而是直接与服务器协商来验证本地缓存的有效性，也就是走下面要讲的协商缓存路线。
                private：资源只能被浏览器缓存，Cache-Control的默认取值。
                must-revalidate：可缓存但必须再向服务器进确认。
                
- 协商缓存: 当 Cache-Control 校验缓存过期，或者设置了no-cache时，浏览器就会与服务器进行协商，判断是重新发起请求、下载完整的响应，还是从本地获取缓存的资源。
            跟协商缓存相关的 Header 字段有Last-Modified / If-Modified-Since、ETag / If-None-Match （分别成对出现）;
    
    Last-Modified / If-Modified-Since:
      在每次服务器返回资源的同时，会在响应头中同时返回Last-Modified字段，它是一个时间戳，表示资源最近一次的修改时间。
      随后我们每次需要发送请求时，会带上一个叫 If-Modified-Since 的时间戳字段，它的值就是上一次 response 返回的 Last-Modified 值。
      
      服务器接收到这个时间戳后，会比对该时间戳和资源在服务器上的最后修改时间：
        如果两者不同，返回200和完整的响应内容。
        如果两者相同，返回304和空的响应体，直接从缓存读取资源。
    
    ETag / If-None-Match:
      Etag 是由服务器为每个资源生成的唯一的标识字符串，类似于文件指纹。和 Last-Modified 类似，当首次请求时，会在响应头返回Etag字段。
      下一次请求时，会将之前响应头中Etag的值作为此次请求头中If-None-Match字段，提供给服务器进行校验。

      若资源没有更新，就返回304和空的响应体，直接从缓存读取资源。否则，就会返回返回更新后的资源并且将新的缓存信息一起返回。
      Etag 在感知文件变化上比 Last-Modified 更加准确，优先级也更高。当 Etag 和 Last-Modified 同时存在时，以 Etag 为准。
  
- 缓存存储位置

    从存储位置来看，浏览器缓存一共分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。
        Service Worker
        Memory Cache
        Disk Cache
        Push Cache

    （1）Service Worker：
        Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。

        Service Worker 实现缓存功能一般分为三个步骤：
            首先需要先注册 Service Worker
            然后监听到 install 事件以后就可以缓存需要的文件
            那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。
            当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。
    （2） Memory Cache
        Memory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。

        ⚠️：内存缓存在缓存资源时并不关心返回资源的HTTP缓存头Cache-Control是什么值，同时资源的匹配也并非仅仅是对URL做匹配，还可能会对Content-Type，CORS等其他特征做校验。
    （3）Disk Cache
        Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache。
    （4）Push Cache
        Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。他有如下的一些特性：

        所有的资源都能被推送，并且能够被缓存,但是 Edge 和 Safari 浏览器支持相对比较差。
        Push Cache 中的缓存只能被使用一次
        可以给其他域名推送资源
        浏览器可以拒绝接受已经存在的资源推送
        一旦连接被关闭，Push Cache 就被释放
        可以推送 no-cache 和 no-store 的资源
        多个页面可以使用同一个HTTP/2的连接，也就可以使用同一个Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的tab标签使用同一个HTTP连接。

- 用户行为对浏览器缓存的控制

    地址栏访问，链接跳转是正常用户行为，将会触发浏览器缓存机制；
    F5刷新，浏览器会设置max-age=0，跳过强缓存判断，会进行协商缓存判断；
    ctrl+F5刷新，跳过强缓存和协商缓存，直接从服务器拉取资源。

- 三级缓存原理 (访问缓存优先级)

    先在内存中查找,如果有,直接加载。
    如果内存中不存在,则在硬盘中查找,如果有直接加载。
    如果硬盘中也没有,那么就进行网络请求。
    请求获取的资源缓存到硬盘和内存。

- 如何在浏览器中判断强制缓存是否生效？
    
    判断是否命中强缓存：当命中强缓存时，状态码为200, 请求对应的Size值则代表该缓存存放的位置，分别为from memory cache 和 from disk cache。from memory cache代表使用内存中的缓存，from disk cache则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为memory > disk。