### js 基本数据类型:

Undefined:
  使用var声明变量但未对其进行初始化，这个变量的值就是undefined。
Null：
  表示一个空对象指针，使用typeof操作符检测null会返回object
Boolean：
  true false
Number:
  十进制、八进制0、十六进制0x NaN:非数值 
  将非数值转换为数值：Number()-可以用于任何数据类型；parseInt() parseFloat() -专门用于把字符串转换成数值；
String
Object：
  var o = new Object()

### null 和 undefined 区别

undefined：是所有没有赋值变量的默认值，自动赋值;
null：主动释放一个变量引用的对象，表示一个变量不再指向任何对象地址,当使用完一个比较大的对象时，需要对其进行释放内存时，设置为null。
共同点：都是原始类型，变量保存在栈中；
不同点：undefined——表示变量声明过但并未赋过值。它是所有未赋值变量默认值。
        null表示一个变量将来可能指向一个对象。一般用于主动释放指向对象的引用。

### var let const区别

var：
  会发生变量提升，即变量可以在声明之前使用，值为undefined
let: 
  所声明的变量只在let命令所在的代码块内有效；
  for循环的计数器适合用let;
  所声明的变量一定要在声明后使用，否则报错。
  let不允许在相同作用域内，重复声明同一个变量。
  let实际上为 JavaScript 新增了块级作用域
const:
  const声明一个只读的常量。一旦声明，常量的值就不能改变;
  const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。
  const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。
  const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心

### typeof 和 instanceof 区别

js是一个弱类型的语言，所以一般想知道当前变量是哪一种类型必须判断类型，都知道判断类型的两种方式：typeof、 instanceof
它们各有缺点：
  typeof适用于基础数据类型判断，引用类型判断都是object。 
  instanceof的用途是判断一个对象是否在某个对象原型链上。或者说判断一个对象是某个对象的实例。    
    a instanceof b：判断a是否为b的实例，可以用于继承关系中。

### instanceof 的原理和弊端
  https://blog.csdn.net/lunahaijiao/article/details/84974355

### JavaScript中事件循环的理解

#### JS同步和异步 事件循环的定义
  同步：前一个任务结束后再执行后一个任务，程序的执行顺序和任务的排列顺序是一致的、同步的。
  异步：一件事情要花很长时间，在做这件事的同时，还可以去处理其他事情。
  
  同步任务：立即执行的任务，同步任务一般会直接进入到主线程中执行，形成一个执行栈；
  异步任务：异步执行的任务，比如ajax网络请求，setTimeout定时函数等
    JS的异步是通过回调函数实现的。一般而言，异步任务有以下三种类型：
      1）普通事件：如click、resize
      2）资源加载：如load、error
      3）定时器：setInterval、setTimeout

  异步任务相关回调函数添加到任务队列中。

  同步任务和异步任务的运行流程图：
  (/image/同步异步.jpg)
    首先判断任务是同步任务还是异步任务，如果是同步任务则将任务放到主线程中执行，主线程中的任务执行完毕后，会读取任务队列中的结果，进入主线程执行；
    异步任务的话，进入任务队列，主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。上述过程的不断重复就是事件循环。

事件队列其实是一个“先进先出”的数据结构，排在前面的事件会优先被主线程读取。
  
#### 宏任务和微任务

异步任务可以分为微任务和宏任务；
(/image/宏任务微任务.jpg)
微任务：
  一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。
常见的微任务：
  Promise.then
  MutaionObserver
  process.nextTick
宏任务：
  宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合
常见的宏任务： 
  script(外层同步代码)
  setTimeout/setInterval
  UI rendering/UI事件
  postMessage、MessageChannel
  setImmediate、I/O（Node.js）
宏任务微任务执行过程：
  执行一个宏任务，如果遇到微任务就将它放到微任务的事件队列中当前宏任务执行完成后，会查看微任务的事件队列，然后将里面的所有微任务依次执行完。

#### async与await
async:异步，await:等待
async就是用来声明一个异步方法，而 await是用来等待异步方法执行；
eg.
  async function fn1 (){
    console.log(1)
    await fn2()
    console.log(2) // 阻塞
  }
  async function fn2 (){
      console.log('fn2')
  }
  fn1()
  console.log(3)
  上面的例子中，await 会阻塞下面的代码（即加入微任务队列），先执行 async外面的同步代码，同步代码执行完，再回到 async 函数中，再执行之前阻塞的代码.所以上述输出结果为：1，fn2，3，2。

一个例子：(/image/事件循环例子.png)

### 异步编程的实现方式
回调函数 - promise - generator(生成器) - async

#### 回调函数：
  回调函数含义：一个函数被作为参数传递给另一个函数（在这里我们把另一个函数叫做“otherFunction”），回调函数在otherFunction中被调用。
 
  eg. click函数
    $("#btn_1").click(function() {
      alert("Btn 1 Clicked");
    });  
    //或者
    function click() { // 它就是回调函数
      alert("Btn 1 Clicked");
    }
    $("#btn_1").click(click);  

  如何运作：因为函数在Javascript中是第一类对象，我们像对待对象一样对待函数，因此我们能像传递变量一样传递函数，在函数中返回函数，在其他函数中使用函数。当我们将一个回调函数作为参数传递给另一个函数是，我们仅仅传递了函数定义。我们并没有在参数中执行函数。我们并不传递像我们平时执行函数一样带有一对执行小括号()的函数。回调函数并不会马上被执行。
  
  优点：简单、容易理解
  缺点：不利于维护，代码耦合高

#### 事件监听（采用时间驱动模式，取决于某个事件是否发生）：
  优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数
  缺点：事件驱动型，流程不够清晰

#### 发布/订阅（观察者模式）
  类似于事件监听，但是可以通过‘消息中心’，了解现在有多少发布者，多少订阅者

#### Promise 对象  
  (https://www.runoob.com/w3cnote/javascript-promise-object.html) 
  C:\Users\CY888\Desktop\笔记\Web 前端知识点 总\05-JavaScript之ES6语法\10-Promise入门详解.md
  
  Promise对象特点： 
    1）对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：pending-初始状态；fulfilled-操作成功完成；rejected-操作失败；只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。
    2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 Pending 变为 Resolved 和从 Pending 变为 Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。
  创建Promise:
    var promise = new Promise(function(resolve, reject) {
      // 异步处理
      // 处理结束后、调用resolve 或 reject
    });
  优点：可以利用 then 方法，进行链式写法；(可以把原本的多层嵌套调用改进为链式调用**)可以书写错误时的回调函数；可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。
  缺点：编写和理解，相对比较难

#### Generator 函数:
  generator（生成器）是ES6标准引入的新的数据类型。一个generator看上去像一个函数，但可以返回多次。
  eg.
    function* fib(max) {
      var
          t,
          a = 0,
          b = 1,
          n = 0;
      while (n < max) {
          yield a;
          [a, b] = [b, a + b];
          n ++;
      }
      return;
    }
  优点：函数体内外的数据交换、错误处理机制
  缺点：流程管理不方便

#### async 函数
  async 函数，使得异步操作变得更加方便。
  async是 Generator 函数的语法糖.async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await。
  async函数对Generator函数的改进(优点)：
    内置执行器、更好的语义、更广的适用性、返回的是 Promise、结构清晰。
    (1)Generator函数函数的执行必须靠执行器，async函数自带执行器
    (2)更好的语义
    (3)更广的适用性:co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。
    (4)async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便.
  缺点：错误处理机制

  用法：async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。

回答：
js 中的异步机制可以分为以下几种：

第一种最常见的是使用回调函数的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。

第二种是 Promise 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。

第三种是使用 generator 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部我们还可以将执行权转移回来。当我们遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕的时候我们再将执行权给转移回来。因此我们在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式我们需要考虑的问题是何时将函数的控制权转移回来，因此我们需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。

第四种是使用 async 函数的形式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此我们可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。

### 类型转换
类型转换分为两种：显示类型转换、隐式类型转换。
通常有三种形式的类型转换：
- 转换为字符串类型
- 转换为数字型
- 转换为布尔型
#### 显示类型转换
- toString():该方法**不会影响到原变量**，它会将转换的结果返回
- String()
- Number()
- parseInt(string):将字符串中的有效的整数内容转为数字;
- parseFloat(string):将字符串转换为**浮点数**;
- Boolean():null 和 undefined 都会转换为 false;数字 --> 布尔。除了 0 和 NaN，其余的都是 true。字符串 ---> 布尔。除了空串，其余的都是 true。引用数据类型会转换为 true。注意，空数组`[]`和空对象`{}`，**转换结果也是 true**。
#### 隐式类型转换
- isNaN ()
- 自增/自减运算符：`++`、`—-`
- 正号/负号：`+a`、`-a`
- 加号：`+`
- 运算符：`-`、`*`、`/`
#### 隐式类型转换（特殊）
- 逻辑运算符：`&&`、`||`、`！` 。非布尔值进行**与或**运算时，会先将其转换为布尔值，然后再运算，但运算结果是**原值**。
- 关系运算符：`<`、`>` `<=` `>=`等。关系运算符，得到的运算结果都是布尔值：要么是true，要么是false。

### es6 数据结构中 map 和 set 有什么不同
#### set:
  Set是ES6新的数据结构，类似数组，但成员的值是唯一的，没有重复的值
  let set = new Set(['a','e','i','o','u','A','E','I','O','U']);
  let ss=new Set([1,2,3,3])
  [...ss] //1,2,3
  https://www.jianshu.com/p/80bf2e6139dc
  set方法：add, delete, has, clear  
          set.add(a) //添加元素
          set.size //得到set的长度
          set.has(val) //has() 方法返回一个布尔值来指示对应的值value是否存在Set对象中。
          set.delete(2);//删除某个值，返回一个布尔值，表示删除是否成功。
          
  遍历方法：set.keys(), set.values(), set.entries(), set.forEach()
  用于：数组去重：
      const set = new Set();  //新建一个set
      for (let i = 0; i < candies.length; i++) {
          set.add(candies[i]);  //遍历set,将元素添加到set中，里面的元素不重复
      }

#### map:
    它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。
    也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。

        const m = new Map();
        m.set(o, 'content') //添加元素
        m.has(o) //判断是否存在该元素
        m.get('name') // "张三" 得到name对应的值

        const map = new Map();
        map.set('foo', true);
        map.set('bar', false);
    
    属性和方法：
    (1) size: size属性返回 Map 结构的成员总数。
        map.size();
    (2) set: set方法设置键名key对应的键值为value，然后返回整个 Map 结构
        m.set(o, 'content');
    (3)get: get方法读取key对应的键值，如果找不到key，返回undefined。
        m.get(hello);
    (4)has: has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。
        m.has(o);
    (5)delete:delete方法删除某个键，返回true。如果删除失败，返回false
        m.delete(o);
    (6)clear:clear方法清除所有成员，没有返回值;
        map.clear();
    
    遍历方法：
        map.keys():
            for (let key of map.keys()) {
                console.log(key);
            }
        map.values();
        map.entries();
        map.foreach();
            map.forEach(function(value, key, map) {
                console.log("Key: %s, Value: %s", key, value);
            });

    eg. 遍历数组，将数组中每个元素出现的次数存储在map的value中。
        let map = new Map();
        for(item of deck){
            map.set(item,map.has(item) ? map.get(item)+1 : 1);
        }
        
### 箭头函数能不能做构造函数，为什么？
(https://blog.csdn.net/weixin_42798473/article/details/105319353)
#### 箭头函数
  const fn2 = (a, b) => a + b;  //只有一条语句，所以可以不用加{}
  箭头函数的好处：
    箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super或new.target。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。

  箭头函数可以让函数写起来更简洁优雅。还有一个很大的作用是与 this 的指向有关。
  ES6 的箭头函数中：**箭头函数本身不绑定 this**，this 指向的是**箭头函数定义位置的 this**（也就是说，箭头函数在哪个位置定义的，this 就跟这个位置的 this 指向相同）。)

  箭头函数它作为一个函数，它是没有prototype属性的。

  (!!!)
    所有的引用类型都有__ proto __属性;
    只有函数对象有prototype属性;
    所有的引用类型的__ proto __属性值均指向它的构造函数的prototype的属性值;
    当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去他的__ proto __(即它的构造函数的prototype）中寻找;

### 构造函数是啥
  构造函数：是一种特殊的函数，主要用来创建和初始化对象，也就是为对象的成员变量赋初始值。它与 `new` 一起使用才有意义。

#### 构造函数和普通函数的区别
  (1) 调用方式不一样。作用也不一样（构造函数用来新建实例对象）;
    普通函数的调用方式：直接调用 person();
    构造函数的调用方式：需要使用new关键字来调用 new Person();内部用this 来构造属性和方法;
  (2) this 的指向也有所不同：
  -   1.以函数的形式调用时，this 永远都是 window。比如`fun();`相当于`window.fun();`
  -   2.以方法的形式调用时，this 是调用方法的那个对象
  -   3.以构造函数的形式调用时，this 是新创建的实例对象

  构造函数的实例可以通过实例的constructor访问对应的构造函数；

### prototype 是啥，什么是原型，什么是实例原型，说说你的理解
(C:\Users\CY888\Desktop\笔记\Web 前端知识点 总\04-JavaScript基础\26-对象的创建&构造函数.md)
(C:\Users\CY888\Desktop\笔记\Web 前端知识点 总\04-JavaScript基础\原型对象.md)
创建自定义对象的几种方法：
  对象字面量：{}
  工厂模式：new Object();
  构造函数；

重写 Person 原型的toString方法。针对 Person 的所有实例生效：
  function Person(name, age, gender) {
      this.name = name;
      this.age = age;
      this.gender = gender;
    }

    Person.prototype.toString = function() {
      return (
        "Person[name=" +
        this.name +
        ",age=" +
        this.age +
        ",gender=" +
        this.gender +
        "]"
      );
    };

#### 原型概念
我们所创建的每一个函数，解析器都会向函数中添加一个属性 prototype。这个属性是一个指针,指向一个对象，这个对象就是我们所谓的原型对象。原型对象的本质也是一个对象。
如果函数作为普通函数调用prototype没有任何作用，当函数以构造函数的形式调用时，它所创建的实例对象中都会有一个隐含的属性，指向该构造函数的原型，我们可以通过__proto__来访问该属性。

#### 原型链
原型链的原理：让一个引用类型继承另一个引用类型的属性和方法；
原型对象通过constructor属性指向构造函数，实例通过Prototype属性指向原型对象；

原型对象也是对象，所以它也有原型，当我们使用或访问一个对象的属性或方法时：
- 它会先在对象自身中寻找，如果有则直接使用；
- 如果没有则会去原型对象中寻找，如果找到则直接使用；
- 如果没有则去原型的原型中寻找，直到找到Object对象的原型。
- Object对象的原型没有原型，如果在Object原型中依然没有找到，则返回 null

### 对象
#### js创建对象的几种方式
我们一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js
和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是我们可以使用函数来进行模拟，从而产生出可复用的对象
创建方式，我了解到的方式有这么几种：

（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。

（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么我们就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此我们可以使用 this 给对象赋值。
  构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次我们都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。

（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。

（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此我们可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。

（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。

（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。


### js继承
ES5 继承和 ES6 继承的区别、ES6 中的继承有什么好处、js 为什么不支持多继承

#### js继承的方式
(https://segmentfault.com/a/1190000008754962)
（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。

（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。 —call()方法；

（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。

（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。

（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。

（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。

#### call() apply() bind()
  允许一个对象调用另一个对象的方法；
  apply 、 call 、bind 三者都是用来改变函数的this对象的指向的；
  apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文；
  apply 、 call 、bind 三者都可以利用后续参数传参；
  bind是返回对应函数，便于稍后调用；apply、call则是立即调用 。



