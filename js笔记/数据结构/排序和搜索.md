## 排序算法

//数组
function ArrayList(){
  var array = [];
  this.insert = function(item){
    array.push(item);
  }
  this.toString = function(){
    return array.join();
  }

  //冒泡排序 O(n的平方)：比较任何两个相邻的项，如果第一个比第二个大，则交换它们。元素项向上移动至
正确的顺序，就好像气泡升至表面一样。
  this.bubbleSort = function(){
    var length = array.length;
    for(var i=0; i< length; i++){
      for(var j=0; j < length-1; j++){
        if(array[ j] > array[ j+1]){
          swap(j,j+1);
        }
      }
    }
  }
  var swap = function(index1, index2){
    var aux = array[ index1];
    array[ index1] = array[ index2]
    array[ index] = aux;
  }
  //修改后的冒泡排序
  this.modifiedBubbleSort = function(){
    var length = array.length;
    for (var i=0; i< length; i++){
      for (var j=0; j< length-1-i; j++ ){   ////
        if (array[ j] > array[ j+1]){
          swap(j, j+1);
        }
      }
    }
  };

  //选择排序 O(n的平方)：找到数据结构中的最小值并将其放置在第一位，接着找到第二小的值并将其放在第二位。
  this.selectSort = function(){
    var length = array.length,
        indexMin;
    for(var i=0; i< length-1; i++){ //控制迭代轮次
      indexMin = i;
      for(var j=i; j< length; j++){
        if(array[ indexMin] > array[ j]){
          indexMin = j;
        }
      }
      if(i !==indexMin){
        swap(i ,indexMin);
      }
    }
  }

  //插入排序 ：插入排序每次排一个数组项，以此方式构建最后的排序数组。假定第一项已经排序了，接着，它和第二项进行比较，第二项是应该待在原位还是插到第一项之前呢。这样，头两项就已正确排序，接着和第三项比较（它是该插入到第一、第二还是第三的位置呢。），以此类推。
  this.insertionSort = function(){
    var length = array.length, j, temp;
    for(let i=1; i< length; i++){
      j = i;
      temp = array[ i]
      while(j>0 && array[ j-1]>temp){
        array[ j] = array[ j-1];
        j--;
      }
      array[ j]=temp;
    }
  }

  //归并排序：归并排序是一种分治算法。其思想是将原始数组切分成较小的数组，直到每个小数组只有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。归并排序是递归的。
  this.mergeSort = function(){
    array = mergeSortRec(array);
  }
  var mergeSortRec = function(array){
    var length = array.length;
    if(length === 1){
      return array;
    }
    var mid = Math.floor(length / 2),
        left = array.slice(0, mid),
        right = array.slice(mid, length);
    return merge(mergeSortRec(left), mergeSortRec(right));
  }
  //负责合并和排序小数组来产生大数组，直到回到原始数组并排序完成;输入两个数组，返回排序并合并后的数组
  var merge = function(left, right){
    var result = [], il=0, ir = 0;
    while(il< left.length && ir < right.length){
      if(left[ il] < right[ ir]){
        result.push( left[ il++])
      }else{
        result.push( right[ ir++])
      }
    }
    while(il < left.length){
      result.push( left[ il++])
    }
    while(ir < right.length){
      result.push( right[ ir++])
    }
    return result;
  }

  //快速排序：O(nlogN)
  this.quickSort = function(){
    quick(array, 0, array.length-1);
  }
  var quick = function(array, left, right){
    var index;
    if(array.length > 1){
      index = partition(array, left, right);
      if(left < index-1){ 
        quick(array, left, index-1)
      }
      if(index < right){
        quick(array,index, right)
      }
    }
  }
  var partition = function(array,left,right){
    var pivot = array[ Math.floor(right + left)/2],
        i = left,
        j = right;
    while(i <=j){
      while(array[i] < pivot){
        i++;
      }
      while(array[j] > pivot){
        j--;
      }
      if(i<=j){
        swapQuickStort(array, i, j);
        i++;
        j--;
      }
    }
    return i;
  }
  var swapQuickStort = function(array, index1, index2){
    var aux = array[ index1];
    array[ index1] = array[ index2];
    array[ index2] = aux;
  }

  //顺序搜索:将每一个数据结构中的元素和我们要找的元素做比较。
  this.sequentialSearch = function(item){
    for(var i=0; i< array.length; i++){
      if(item === array[ i]){
        return i;
      }
    }
    return -1;
  }

  //二分搜索
  this.binarySearch = function(item){
    this.quickSort();
    var low = 0, high = array.length-1, mid, element;
    while( low <= high){
      mid = Math.floor((low+high)/2)
      element = array[ mid];
      if(element< item){
        low = mid + 1;
      }else(element >item){
        high = mid -1;
      }else{
        return mid;
      }
      return -1;
    }
  }

}

//动态规划：最少硬币找零问题
function MinCoinChange(coins){
  var coins = coins; 
  var cache = {}; 
  this.makeChange = function(amount) {
    var me = this;
    if (!amount) { 
      return [];
    }
    if (cache[  amount]) { 
      return cache[ amount];
    }
    var min = [], newMin, newAmount;
    for (var i=0; i< coins.length; i++){ 
    var coin = coins[ i];
    newAmount = amount - coin; 
    if (newAmount >= 0){
      newMin = me.makeChange(newAmount); 
    }
    if (
      newAmount >= 0 && 
      (newMin.length < min.length-1 || !min.length)
      && (newMin.length || !newAmount)
    ){
      min = [coin].concat(newMin);
      console.log('new Min ' + min + ' for ' + amount);
    }
    }
    return (cache[amount] = min);
  };
}