## 图的表示

### 邻接矩阵
  每个节点都和一个整数相关联，该整数将作为数组的索引。用一个二维数组来表示顶点之间的连接。如果索引为i的节点和索引为j的节点相邻，则array[i][j]=== 1，否则array[i][j] === 0。

### 邻接表
  邻接表由图中每个顶点的相邻顶点列表所组成。

### 关联矩阵
矩阵的行表示顶点，列表示边。使用二维数组来表示两者之间的连通性，如果顶点v是边e的入射点，则array[v][e] === 1；否则， array[v][e] === 0。

### 创建图
function Graph(){
  var vertices = []; //存储顶点
  var adjList = new Dictionary(); //存储邻接表

  //添加顶点
  this.addVertex = function(v){
    vertices.push(v);
    adjList.set(v, []);
  }

  //添加边
  this.addEdge = function(v, w){
    adjList.get(v).push(w);
    adjList.get(w).push(v);
  }

  this.toString = function(){
    var s = '';
    for(var i=0; i< vartices.length; i++){
      s += vertices[i] + '->';
      var neighbors = adjList.get(vertices[i]);
      for(var j =0; j< neighbors.length; j++){
        s +=neighbors[j] + ' '
      }
      s +='\n'
    }
    return s;
  }
}

### 图的遍历
广度优先搜索（Breadth-First Search， BFS）和深度优先搜索（Depth-First Search， DFS）。图遍历可以用来寻找特定的顶点或寻找两个顶点之间的路径，检查图是否连通，检查图是否含有环等。

#### 广度优先搜索算法-队列
var initializeColor = function(){
  var color = [];
  for(var i=0; i< vertices.length; i++){
    color[vertices[ i]] = 'white'
  }
  return color;
}
this.bfs = function(v, callback){
  var color = initializeColor(),
      queue = new Queue();
  queue.enqueue(v);

  while(!queue.isEmpty()){
    var u = queue.dequeue(),
        neighbors = adjList.get(u);
    color[ u] = 'grey';
    for(let i =0; i< neighbors.length; i++){
      var w = neighbors[i];
      if(color[w] === 'white'){
        color[w] = 'grey';
        queue.enqueue(w);
      }
    }
    color[ u] = 'black'
    if(callback){
      callback[ u]
    }
  }
}

#### 深度优先搜索算法-栈
  this.dfs = function(callback){
    var color = initializeColor(); 
    for (var i=0; i< vertices.length; i++){ 
      if (color[ vertices[i]] === 'white'){ 
        dfsVisit(vertices[ i], color, callback); 
      }
    }
  };
  var dfsVisit = function(u, color, callback){
    color[u] = 'grey'; 
    if (callback) {
      callback(u);
    }
    var neighbors = adjList.get(u); 
    for (var i=0; i< neighbors.length; i++){ 
      var w = neighbors[i];
      if (color[w] === 'white'){ 
        dfsVisit(w, color, callback); 
      }
    }
    color[u] = 'black'; //{12}
  };