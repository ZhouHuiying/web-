### 树

二叉树：
  节点最多只有两个子节点，一个是左侧子节点，一个是右侧子节点。

二叉搜索树：
  是二叉树的一种，但是它只允许你在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大（或者等于）的值。
  二叉查找树（Binary Search Tree），它或者是一棵空树，或者是具有下列性质的二叉树： 
    若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
    它的左、右子树也分别为二叉排序树。
    二叉搜索树作为一种经典的数据结构，它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势；
    应用十分广泛，例如在文件系统和数据库系统一般会采用这种数据结构进行高效率的排序与检索操作

### 创建BinarySearchtree

function BinarySearchTree(){
  var Node = function(key){
    this.key = key;
    this.left = null;
    this.right = null;
  }
  var root = null;

  //向树中插入一个键
  this.insert = function(key){
    var newNode = new Node(key); //创建用来表示新节点的Node类实例
    if(root = null){
      root = new Node;
    }else{
      insertNode(root, newNode);
    }
  }
  var insertNode = function(node, newNode){
    if(newNode.key < node.key){
      if(node.left === null){
        node.left = newNode;
      }else{
        insertNode(node.left, newNode)
      }
    }else{
      if(node.right === null){
        node.right = newNode;
      }else{
        insertNode(node.right, newNode)
      }
    }
  }

  //中序遍历：中序遍历是一种以上行顺序访问BST所有节点的遍历方式，也就是以从最小到最大的顺序访
问所有节点-对树进行排序（从小到大）;
  //中序遍历的一种应用就是对树进行排序；
  this.inOrderTraverse = function(callback){
    inOrderTraverse(root, callback)
  }
  var inOrderTraverseNode = function(node, callback){
    if(node !== null){
      inOrderTraverseNode(node.left, callback)
      callback(node.key);
      inOrderTraverseNode(node.right, callback)
    }
  }
  //回调函数callback 可以定义如下：
  function printNode(value){
    console.log(value)
  }


  //先序遍历：先访问节点本身，然后再访问它的左侧子节点，最后是右侧子节点
  this.preOrderTraverse = function(callback){
    preOrderTraverseNode(root, callback);
  }
  var preOrderTraverseNode = function(node, callback){
    if(node !== null){
      callback(node.key);
      preOrderTraverseNode(node.left, callback);
      preOrderTraverseNode(node.right, callback);
    }
  }


  //后序遍历
  this.postOrderTraverse = function(callback){
    preOrderTraverseNode(root, callback);
  }
  var postOrderTraverseNode = function(node, callback){
    if(node !== null){
      postOrderTraverseNode(node.left, callback);
      postOrderTraverseNode(node.right, callback);
      callback(node.key);
    }
  }


  //寻找树的最小键
  this.min = function(){
    return minNode(root);
  }
  var minNode = function(node){
    if(node){
      while(node && node.left!==null){
        node = node.left;
      }
      return node.key;
    }
    return null;
  }

  
  //寻找树的最大键
  this.max = function(){
    return maxNode(root);
  }
  var minNode = function(node){
    if(node){
      while(node && node.right!==null){
        node = node.right;
      }
      return node.key;
    }
    return null;
  }

  //搜索一个特定的值
  this.search = function(key){
    return searchNode(root, key)
  }
  var searchNode = function(node, key){
    if(node === null){
      return false;
    }else if(key < node.val){
      return searchNode(node.left, key);
    }else if(key > node.val){
      return searchNode(node.right, key);
    }else{
      return true;
    }
  }

  //移除一个节点
  this.remove = function(key){
    root.removeNode(root, key);
  }
  var removeNode = function(node, key){
    if(node === null){
      return null;
    }
    if(key < node.key){
      node.left = removeNode(node.left, key);
      return node;
    }else if(key > node.key){
      node.right = removeNode(node.right, key)
      return node;
    }else{ // key=node
      //第一种情况：一个叶节点
      if(node.left ==null && node.right==null){
        node = null;
        return null;
      }
      //第二种情况：只有一个子节点
      if(node.left===null){
        node = node.right;
        return node;
      }else if(node.right ===null){
        node = node.left;
        return node;
      }

      //第三种情况：有两个子节点
      var aux = findMinNode(node.right);
      node.key = aux.key;
      node.right = removeNode(node.right, aux.key);
      return node;
    }
  }
}

### 求树的深度函数

function depth(node){ //node：树节点
    if(!node) return 0;
    return Math.max(depth(node.left), depth(node.right)) + 1;
}

### 判断两个二叉树是否相同 - 深度优先搜索  递归
  function isSameTree(p, q) {   
    if(p==null && q==null){
        return true;
    }else if(p==null || q==null){
        return false;
    }else if(p.val!=q.val){
        return false;
    }else{
        return isSameTree(p.left,q.left) && isSameTree(p.right, q.right);
    }
  };


### 尝试用迭代？？？
力扣树的遍历-dfs  https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/solution/yi-tao-quan-fa-shua-diao-nge-bian-li-shu-de-wen--3/
eg.中序遍历 leetcode No.94
  递归：
    var inorderTraversal = function(root) {
        let res = [];
        let traversal = function(node){
            if(node!==null){
                traversal(node.left);
                res.push(node.val);
                traversal(node.right);
            }
        }
        traversal(root);
        return res;
    };
  迭代：
    var inorderTraversal = function(root) {
      const res = [];
      const stk = [];
      while (root || stk.length) {
          while (root) {
              stk.push(root);
              root = root.left;
          }
          root = stk.pop();
          res.push(root.val);
          root = root.right;
      }
      return res;
  };
