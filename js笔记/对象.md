### 对象

#### 创建对象
    分为自定义对象，内置对象，浏览器对象；
    (1)利用对象字面量创建对象：var obj={uname:'张三',age=18}

    (2)利用new Object创建对象：var obj=new Object(); obj.age=18;
        JavaScript有个内嵌的方法create(), 它允许您基于现有对象创建新的对象: var person2 = Object.create(person1); 基于person1创建person2

    (3)利用构造函数创建对象：构造函数就是把对象里面相同的属性和方法抽象出来封装到函数里面  函数名大写; 不需要return; 调用必须使用new; 
        function 构造函数名(){
            this.属性 = 值；
            this.方法=function(){}
        }
        new 构造函数名(); 

        function Star(uname,age,sex){
            this.name=uname;
            this.age=age;
            this.sex=sex;
        }
        var ldh = new Star('ldh',18,'男');

    构造函数是泛指的某一大类，对象是特指一个具体的事务，利用构造函数创建对象的过程称为对象的实例化

    new关键字执行过程：new构造函数可以在内存中创建一个空的对象，this就会指向刚才创建的空对象，执行构造函数里面的代码给空对象添加属性和方法，返回这个对象

#### 遍历对象：
(1) for in 循环遍历对象自身的和继承的可枚举属性(不含Symbol属性)for(变量 in 对象)
  for(var k in obj){
      console.log(k) 得到的是属性名
      console.log(obj[k]) 得到的是属性值
  }
(2)使用Object.keys()遍历
  var obj = {0:a, 1:b, 2:c};
  Object.keys(obj).forEach(function(key){
    console.log(key, obj[ key])
  })
(3)使用Object.getOwnPropertyNames(obj)遍历
  var obj = {'0':'a','1':'b','2':'c'};
  Object.getOwnPropertyNames(obj).forEach(function(key){
    console.log(key,obj[key]);
  });
(4)使用Reflect.ownKeys(obj)遍历
  var obj = {'0':'a','1':'b','2':'c'};
  Reflect.ownKeys(obj).forEach(function(key){
    console.log(key,obj[key]);
  });
  
#### 删除对象属性：
        eg.
            var canPermutePalindrome = function(s) {
                let obj = {};
                for(let i=0; i<s.length; i++){
                    let char = s[i];
                    if(obj[char])
                        delete obj[char]   //
                    else
                        obj[char] = 1;
                }
                return Object.keys(obj).length <= 1;
            };  

### 原型链：
        https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object_prototypes
        JavaScript 常被描述为一种基于原型的语言 (prototype-based language)——每个对象拥有一个原型对象，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。
        
        每个函数都有一个特殊的属性叫作原型（prototype）。
        ```
        function doSomething(){}
        console.log( doSomething.prototype );
        ```
        原型链中的方法和属性没有被复制到其他对象——它们被访问需要通过前面所说的“原型链”的方式。
        prototype 属性：
            以 Object.prototype. 开头的属性: prototype 属性的值是一个对象，我们希望被原型链下游的对象继承的属性和方法，都被储存在其中。
            即：prototype 属性包含（指向）一个对象，你在这个对象中定义需要被继承的成员。
            JavaScript 中到处都是通过原型链继承的例子:
                var myString = 'This is my string.';
                myString 立即具有了一些有用的方法，如 split()、indexOf()、replace() 等。
        constructor 属性：
            person1.constructor person2.constructor 都将返回 Person() 构造器，因为该构造器包含这些实例的原始定义。
    
    原型链继承（原型式继承）：
        call()函数：这个函数允许调用一个在这个文件里别处定义的函数。 
        eg:
            ```
            function Person(first, last, age, gender, interests) {
                this.name = {
                    first,
                    last
                };
                this.age = age;
                this.gender = gender;
                this.interests = interests;
            };
            function Teacher(first, last, age, gender, interests, subject) {
                Person.call(this, first, last, age, gender, interests);

                this.subject = subject;
            }
            ```
    JavaScript Object Notation (JSON)
            


### 内置对象：

#### Math对象：
    不是一个构造函数，不需要new
    Math.abs(1); 1 绝对值
    Math.floor(1.1);  1 向下取整
    Math.ceil(1.1);  2 向上取整
    Math.round(1.1); 1 四舍五入
    Math.random(); 返回一个浮点数，[0，1)
    Math.abs(): 返回数的绝对值
    Math.trunc(8.75): 返回数字的整数部分。 此方法不会将数字向上/向下舍入到最近的整数，而只是删除小数。
    Math.pow(10,9): 10的九次方

    eg.
    (1)求两点之间的距离：
        var pos = cc.v2(100,200);
        var pos2 = cc.v2(300,400);
        var distance = Math.sqrt(Math.pow(pos.x - pos2.x, 2) + Math.pow(pos.y - pos2.y, 2));
    
#### 日期对象：
    是构造函数，必须使用new来调用创建日期对象
    var myDate = new Date();
    格式化年月日
        myDate.getYear(); //获取当前年份(2位)
        myDate.getFullYear(); //获取完整的年份(4位,1970-????)
        myDate.getMonth(); //获取当前月份(0-11,0代表1月)
        myDate.getDate(); //获取当前日(1-31)
        myDate.getDay(); //获取当前星期X(0-6,0代表星期天)
        myDate.getTime(); //获取当前时间(从1970.1.1开始的毫秒数)
        myDate.getHours(); //获取当前小时数(0-23)
        myDate.getMinutes(); //获取当前分钟数(0-59)
        myDate.getSeconds(); //获取当前秒数(0-59)
        myDate.getMilliseconds(); //获取当前毫秒数(0-999)
        myDate.toLocaleDateString(); //获取当前日期
        
        var mytime = myDate.toLocaleTimeString(); //获取当前时间
        myDate.toLocaleString( ); //获取日期与时间
                
    获取日期的总的毫秒数：1970-1-1开始 
        var date=new Date();  date.valueOf();
        var date1 = +new Date(); ——最常用的写法
        Data.now();  
       
#### 字符串对象：
    基本包装类型：把简单数据类型包装为复杂数据类型,这个简单数据类型就有了属性和方法；String、Number、Boolean；
    字符串的不可变： 开辟新的内存空间；

    根据字符返回位置：
        indexOf(): str.indexOf('春',[3]); 从第三个开始查找春
	                indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。 ]
	                indexOf() 方法对大小写敏感,    如果要检索的字符串值没有出现，则该方法返回 -1。
        lastIndexOf(): lastIndexOf() 方法可返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。
                    stringObject.lastIndexOf(searchvalue,fromindex)

    根据位置返回字符： 
        charAt(index):  根据位置返回字符；
            str.charAt(3); //查找第三个位置的字符
            var str = "HELLO WORLD";
            var n = str.charAt(2)
        charAt() 方法可返回指定位置的字符。 必需。表示字符串中某个位置的数字，即字符在字符串中的下标;

    charCodeAt(index):  返回相应索引号的字符ASCII值 目的：判断用户按下了哪个键； str.charCodeAt(0);
        str[index]： str[0];

    字符串操作方法：
        concat('字符串1','字符串2'...)； 类似+号

        substr(start,length):  str.substr(2,2) 2号位置取两个字符； 

        slice(start,end):

        substring(start,end):

        replace：替换字符 replace('被替换的字符','替换为的字符') 只会替换第一个字符
            stringObject.replace(regexp/substr,replacement);
                regexp/substr:
                    必需。规定子字符串或要替换的模式的 RegExp 对象。
                    请注意，如果该值是一个字符串，则将它作为要检索的直接量文本模式，而不是首先被转换为 RegExp 对象。
                replacement: 必需。一个字符串值。规定了替换文本或生成替换文本的函数。
            返回值: 一个新的字符串，是用 replacement 替换了 regexp 的第一次匹配或所有匹配之后得到的。

        spilt('分隔符'): 字符转换成数组 var str='1,2';  str.spilt(',');  

        match(): 可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配;
                 该方法类似 indexOf() 和 lastIndexOf()，但是它返回指定的值，而不是字符串的位置。
                stringObject.match(searchvalue)
                stringObject.match(regexp)

        indexOf(): indexOf()方法可返回某个指定的字符串值在字符串中首次出现的位置; 对大小写敏感；
                    stringObject.indexOf(searchvalue,fromindex);
        
        lastIndexOf(): lastIndexOf()方法可返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索;对大小写敏感；
                    stringObject.lastIndexOf(searchvalue,fromindex);
        
        padStart(),padEnd(): padStart()用于头部补全，padEnd()用于尾部补全；
            str.padStart(位数,补全内容);
            str.padEnd(位数,补全内容);
        
        localeCompare():
            定义：用本地特定的顺序来比较两个字符串。
    　　    语法：stringObject.localeCompare(target)
    　　    参数：target——要以本地特定的顺序与 stringObject 进行比较的字符串。

            返回值：说明比较结果的数字。
            　　（1）如果 stringObject 小于 target，则 localeCompare() 返回小于 0 的数。
            　　（2）如果 stringObject 大于 target，则该方法返回大于 0 的数。
            　　（3）如果两个字符串相等，或根据本地排序规则没有区别，该方法返回 0。

            　　说明：把 < 和 > 运算符应用到字符串时，它们只用字符的 Unicode 编码比较字符串，而不考虑当地的排序规则。以这种方法生成的顺序不一定是正确的。
                      localeCompare() 方法提供的比较字符串的方法，考虑了默认的本地排序规则。ECMAscript 标准并没有规定如何进行本地特定的比较操作，它只规定该函数采用底层操作系统提供的排序规则。

#### 闭包：一个闭包，就是 一个函数 与其 被创建时所带有的作用域对象 的组合。闭包允许你保存状态——所以，它们可以用来代替对象。
    js: 环境   全局环境不会被回收
        作用域：

#### 其他
    (1) charCodeAt：charCodeAt() 方法可返回指定位置的字符的 Unicode 编码。这个返回值是 0 - 65535 之间的整数。
                charAt() 方法可返回指定位置的字符。

    (2) parseInt() 函数可解析一个字符串，并返回一个整数。
                parseInt(string, radix)   radix: 可选。表示要解析的数字的基数
            
                eg.二进制十进制之间转换
                    十进制转二进制： 
                        var a=20;
                        a.toString(2)
                    二进制转十进制：
                        parseInt('11001', 2)
                        parseInt() 函数可解析一个字符串，并返回一个整数。
                        parseInt(string, radix)   radix: 可选。表示要解析的数字的基数

    (3) BigInt:
        BigInt数据类型的目的是比Number数据类型支持的范围更大的整数值。在对大整数执行数学运算时，以任意精度表示整数的能力尤为重要。
